\section{Introduction}

Superscalar processors with deep pipelines and out-of-order execution represent the state of the art in processor architecture. \\
Superscalar processors have multiple execution unit which allows them to fetch, decode, and execute multiple instructions in parallel through separate pipeline stages within a single clock cycle. This increases the instructions throughput and allows for an Instructions Per Cycle (IPC) count that is greater than 1. The latest main vendor's architectures, AMD Zen5 and Intel Alder Lake, feature cores that are respectively 8 and 6 instructions wide. \\
When talking about deep pipelines, we refer to the number of stages that the instructions have to go through from the fetch to the moment they are retired. High performance design employ different pipelines for different classes of instructions. For both the last generation of AMD and Intel desktop processors, the depth of the integer pipeline is estimated to be 19 stages. \\
When talking about Out of Order Execution, we refer to architecture design where instructions can be executed as soon as their input operands are ready, rather than strictly in the original program order. By executing instructions out of order, the processor can keep its execution units busy even when some instructions are stalled due to delays like cache misses or data dependencies. 

These design choices proved to deliver unmatched performances when provided with enough Instruction Level Parallelism (ILP). Based on the work of August et al.~\cite{August98}, the main obstacles to high ILP are difficult to predict control flows and ambiguous memory dependencies. 

\subsection{The cost of branch misprediction}
\label{sec:costo_of_branch_prediction}
The reason why branch mispredictions represent a big obstacle for modern machines has to do with the design choices described so far. \\
Another central component of modern designs are branch predictors. Branch predictors allow for one side of conditional branches to be speculatively executed before the branch is evaluated. When the speculated side and the evaluated side coincide, we have the benefit of keeping the pipeline full and executing instructions ahead of time. When these speculations fail, tough, the instructions speculatively executed will need to be discarded and the right side will need to be executed. Due to out of order execution, between the time the branch is speculatively executed and the time it is evaluated, a high number of instruction might have been retired. In addition to this, as the pipelines are deep, several cycles have to pass before the pipeline is filled again and start retiring new instruction.
Based on the work of Kwan Lin et al. ~\cite{lin2019branch}, branch misprediction account for 20\% of the IPC in modern processor and is representing the main limit to having deeper, more efficient pipelines. A good empirical average measure of the cost of a branch misprediction comes from the weight used in the heuristics of  \textit{llvm} \cite{Lattner2004LLVM}.

\begin{table}[H]
    \captionsetup{type=table}
    \centering
    \input{src/table/tab_penalties_1}
    \caption[Branch Misprediction Penalty]{Branch Misprediction Penalty and Optimistic Load Cost used in \textit{llvm}'s heuristics for various Intel and ARM architectures.}
    \label{tab:misprediction_penalty}
\end{table}

From the weight used in \textit{llvm} for both branch misprediction and optimistic load cost reported in Table \ref{tab:misprediction_penalty}, we can conclude that a branch misprediction, in a modern high performance architecture, is three times more expensive than a load operation that hits the L1 cache. Certain design choices peculiar to the embedded field make the cost of branch misprediction higher or lower. The data regarding \texttt{Cortex R52} and \texttt{Cortex M4} have been cherry-picked precisely to describe this. The \texttt{Cortex R52} is a design that implements advanced safety features like lockstep redundancy which introduces further overhead in case of misprediction. Due to these characteristics, it has a misprediction penalty to load cost ratio of 8:1. \texttt{Cortex M4} is also an embedded processor but has a 3 stages pipeline and execute instructions in order. This results in a ratio of branch misprediction cost to load cost of 1:1.
The way the weights reported are used by the compiler's heuristics are treated in more detail in Sections \ref{}, \ref{} and \ref{}.

\subsection{Compilation techniques to improve IPC}

Two techniques have been introduced into compilers to try to mitigate the obstacles to high IPC described so far:

\begin{itemize}
    \item \textbf{Speculation}: Is a technique where the compiler makes assumptions about the programâ€™s behavior to generate optimized code paths, potentially executing certain operations early or avoiding them entirely. If the speculated outcomes are incorrect at runtime, mechanisms like rollback or patching are used to maintain correctness. This has not to be confused with branch speculation, which is executed at the architectural level with the aid of the branch predictor.
    \item \textbf{Predication}: Instead of using conditional branches to decide which instructions to execute, predicated instructions execute all possible paths but only commit the results of the path that meets a specific condition, known as the predicate. This is only possible when the Instruction Set Architecture (ISA) supports predicated instructions.
\end{itemize} 

We discuss in more detail how Speculation and Predication help delivery higher performances respectively in Section \ref{sec:speculation} and in Section \ref{sec:predication}. Additionally, we discuss in Section \ref{sec:predication_and_speculation} how these techniques can be combined to achieve even greater benefit  in Section \ref{sec:predication} 

\newpage